# HTTPS客户端开发指南

本指南介绍如何使用 fafafa.ssl 开发HTTPS客户端应用。

---

## 目录

- [快速开始](#快速开始)
- [基础概念](#基础概念)
- [实战场景](#实战场景)
- [最佳实践](#最佳实践)
- [常见问题](#常见问题)

---

## 快速开始

### 最简单的方式（推荐）

```pascal
uses
  fafafa.ssl.http.simple;

var
  LResponse: string;
begin
  LResponse := TSimpleHTTPSClient.Get('https://api.example.com/data');
  WriteLn(LResponse);
end;
```

**就这么简单！** 一行代码完成HTTPS GET请求。

---

## 基础概念

### 连接流程

```
1. 创建SSL上下文 (Context)
2. 配置参数 (证书、验证等)
3. 创建连接 (Connection)
4. TLS握手
5. 发送/接收数据
6. 关闭连接
```

### 两种API级别

#### 高层API（推荐初学者）

```pascal
// 一行代码搞定
LResponse := TSimpleHTTPSClient.Get(LURL);
```

**优点**: 简单、快速、代码量少  
**适合**: API调用、爬虫、文件下载

#### 标准API（需要精确控制时）

```pascal
// 完整控制
LContext := TSSLFactory.CreateContext(sslOpenSSL, sslCtxClient);
LConnection := LContext.CreateConnection;
LConnection.Connect(AHost, APort);
// ... 使用连接
```

**优点**: 完整控制、长连接、特殊配置  
**适合**: 长连接应用、特殊协议、性能优化

---

## 实战场景

### 场景1：REST API调用

#### 简单GET请求

```pascal
uses
  fafafa.ssl.http.simple, fpjson;

function GetUserInfo(const AUserID: string): TJSONObject;
var
  LURL, LResponse: string;
begin
  LURL := Format('https://api.example.com/users/%s', [AUserID]);
  LResponse := TSimpleHTTPSClient.Get(LURL);
  Result := TJSONObject(GetJSON(LResponse));
end;

// 使用
var
  LUser: TJSONObject;
begin
  LUser := GetUserInfo('123');
  try
    WriteLn('Name: ', LUser.Get('name', ''));
    WriteLn('Email: ', LUser.Get('email', ''));
  finally
    LUser.Free;
  end;
end;
```

#### POST创建资源

```pascal
function CreateUser(const AName, AEmail: string): Boolean;
var
  LURL, LData, LResponse: string;
  LOptions: THTTPSOptions;
begin
  LURL := 'https://api.example.com/users';
  
  // 构建JSON数据
  LData := Format('{"name":"%s","email":"%s"}', [AName, AEmail]);
  
  // 设置选项
  LOptions := TSimpleHTTPSClient.DefaultOptions;
  try
    LOptions.Headers.Add('Content-Type: application/json');
    
    // 发送POST请求
    LResponse := TSimpleHTTPSClient.PostEx(LURL, LData, LOptions);
    
    Result := LResponse.Success;
  finally
    LOptions.Headers.Free;
    LResponse.Headers.Free;
  end;
end;
```

#### 认证请求

```pascal
function AuthenticatedGET(const AURL, AToken: string): string;
var
  LOptions: THTTPSOptions;
  LResponse: THTTPResponse;
begin
  LOptions := TSimpleHTTPSClient.DefaultOptions;
  try
    // 添加Authorization头
    LOptions.Headers.Add(Format('Authorization: Bearer %s', [AToken]));
    
    LResponse := TSimpleHTTPSClient.GetEx(AURL, LOptions);
    
    if LResponse.Success then
      Result := LResponse.Body
    else
      raise Exception.CreateFmt('API错误: %d %s', 
        [LResponse.StatusCode, LResponse.ErrorMessage]);
  finally
    LOptions.Headers.Free;
    LResponse.Headers.Free;
  end;
end;
```

---

### 场景2：文件下载

#### 简单下载

```pascal
procedure DownloadFile(const AURL, ADestination: string);
begin
  if TSimpleHTTPSClient.Download(AURL, ADestination) then
    WriteLn('下载成功: ', ADestination)
  else
    WriteLn('下载失败');
end;

// 使用
DownloadFile('https://example.com/file.zip', 'local_file.zip');
```

#### 带进度的下载

```pascal
procedure DownloadWithProgress(const AURL, ADestination: string);
var
  LProgress: TProgressCallback;
begin
  LProgress := procedure(ATotal, ACurrent: Int64)
    begin
      Write(#13, Format('下载进度: %d/%d (%.1f%%)', 
        [ACurrent, ATotal, (ACurrent / ATotal) * 100]));
    end;
  
  if TSimpleHTTPSClient.Download(AURL, ADestination, LProgress) then
  begin
    WriteLn;
    WriteLn('下载完成！');
  end;
end;
```

---

### 场景3：网络爬虫

```pascal
uses
  fafafa.ssl.http.simple, RegExpr;

type
  TCrawler = class
  private
    FBaseURL: string;
    FVisited: TStringList;
  public
    constructor Create(const ABaseURL: string);
    destructor Destroy; override;
    
    procedure Crawl(const AURL: string);
    function ExtractLinks(const AHTML: string): TStringList;
  end;

constructor TCrawler.Create(const ABaseURL: string);
begin
  inherited Create;
  FBaseURL := ABaseURL;
  FVisited := TStringList.Create;
  FVisited.Sorted := True;
  FVisited.Duplicates := dupIgnore;
end;

destructor TCrawler.Destroy;
begin
  FVisited.Free;
  inherited;
end;

procedure TCrawler.Crawl(const AURL: string);
var
  LHTML: string;
  LLinks: TStringList;
  i: Integer;
begin
  // 避免重复访问
  if FVisited.IndexOf(AURL) >= 0 then
    Exit;
  FVisited.Add(AURL);
  
  WriteLn('抓取: ', AURL);
  
  try
    // 获取页面
    LHTML := TSimpleHTTPSClient.Get(AURL);
    
    // 处理页面内容...
    
    // 提取链接
    LLinks := ExtractLinks(LHTML);
    try
      for i := 0 to LLinks.Count - 1 do
        Crawl(LLinks[i]);  // 递归抓取
    finally
      LLinks.Free;
    end;
    
  except
    on E: Exception do
      WriteLn('错误: ', E.Message);
  end;
  
  Sleep(100);  // 礼貌延迟
end;

function TCrawler.ExtractLinks(const AHTML: string): TStringList;
var
  LRegEx: TRegExpr;
begin
  Result := TStringList.Create;
  LRegEx := TRegExpr.Create;
  try
    LRegEx.Expression := '<a\s+href="([^"]+)"';
    if LRegEx.Exec(AHTML) then
    repeat
      Result.Add(LRegEx.Match[1]);
    until not LRegEx.ExecNext;
  finally
    LRegEx.Free;
  end;
end;

// 使用
var
  LCrawler: TCrawler;
begin
  LCrawler := TCrawler.Create('https://example.com');
  try
    LCrawler.Crawl('https://example.com');
  finally
    LCrawler.Free;
  end;
end;
```

---

### 场景4：批量API调用

```pascal
procedure BatchAPICall(const AUserIDs: array of string);
var
  i: Integer;
  LURL, LResponse: string;
  LOptions: THTTPSOptions;
  LStartTime: TDateTime;
begin
  LOptions := TSimpleHTTPSClient.DefaultOptions;
  LOptions.Timeout := 10000;  // 10秒超时
  
  try
    WriteLn(Format('开始批量调用 %d 个API...', [Length(AUserIDs)]));
    LStartTime := Now;
    
    for i := 0 to High(AUserIDs) do
    begin
      LURL := Format('https://api.example.com/users/%s', [AUserIDs[i]]);
      
      try
        LResponse := TSimpleHTTPSClient.GetEx(LURL, LOptions).Body;
        WriteLn(Format('[%d/%d] 成功: %s', 
          [i+1, Length(AUserIDs), AUserIDs[i]]));
      except
        on E: Exception do
          WriteLn(Format('[%d/%d] 失败: %s - %s', 
            [i+1, Length(AUserIDs), AUserIDs[i], E.Message]));
      end;
    end;
    
    WriteLn(Format('完成！耗时: %d 秒', 
      [SecondsBetween(Now, LStartTime)]));
      
  finally
    LOptions.Headers.Free;
  end;
end;

// 使用
var
  LUserIDs: array[0..9] of string = (
    '1', '2', '3', '4', '5', '6', '7', '8', '9', '10'
  );
begin
  BatchAPICall(LUserIDs);
end;
```

---

## 最佳实践

### 1. 错误处理

```pascal
procedure SafeHTTPSRequest(const AURL: string);
begin
  try
    LResponse := TSimpleHTTPSClient.Get(AURL);
    // 处理响应...
  except
    on E: EHTTPSClientException do
    begin
      // HTTP错误（4xx, 5xx）
      WriteLn('HTTP错误: ', E.StatusCode, ' - ', E.Message);
    end;
    on E: ESSLException do
    begin
      // SSL错误（证书、握手等）
      WriteLn('SSL错误: ', E.Message);
    end;
    on E: Exception do
    begin
      // 其他错误（网络、超时等）
      WriteLn('一般错误: ', E.Message);
    end;
  end;
end;
```

### 2. 超时设置

```pascal
// 快速API
LOptions.Timeout := 5000;   // 5秒

// 一般请求
LOptions.Timeout := 30000;  // 30秒

// 大文件下载
LOptions.Timeout := 300000; // 5分钟
```

### 3. 重试机制

```pascal
function RetryRequest(const AURL: string; AMaxRetries: Integer = 3): string;
var
  LRetry: Integer;
  LWaitTime: Integer;
begin
  LWaitTime := 1000;  // 初始等待1秒
  
  for LRetry := 1 to AMaxRetries do
  begin
    try
      Result := TSimpleHTTPSClient.Get(AURL);
      Exit;  // 成功
    except
      on E: Exception do
      begin
        WriteLn(Format('尝试 %d/%d 失败: %s', 
          [LRetry, AMaxRetries, E.Message]));
        
        if LRetry < AMaxRetries then
        begin
          Sleep(LWaitTime);
          LWaitTime := LWaitTime * 2;  // 指数退避
        end
        else
          raise;  // 最后一次失败，抛出异常
      end;
    end;
  end;
end;
```

### 4. 内存管理

```pascal
procedure ProperMemoryManagement;
var
  LOptions: THTTPSOptions;
  LResponse: THTTPResponse;
begin
  // 创建Options
  LOptions := TSimpleHTTPSClient.DefaultOptions;
  try
    // 使用Options
    LResponse := TSimpleHTTPSClient.GetEx(LURL, LOptions);
    try
      // 使用响应
      WriteLn(LResponse.Body);
    finally
      LResponse.Headers.Free;  // 释放响应头
    end;
  finally
    LOptions.Headers.Free;  // 释放选项头
  end;
end;
```

### 5. 日志记录

```pascal
uses
  fafafa.ssl.logger;

var
  GLogger: ILogger;

procedure InitLogger;
begin
  GLogger := TConsoleLogger.Create('https_client.log', llInfo);
end;

function LoggedRequest(const AURL: string): string;
begin
  GLogger.Info('开始请求: ' + AURL);
  
  try
    Result := TSimpleHTTPSClient.Get(AURL);
    GLogger.Info(Format('请求成功: %d 字节', [Length(Result)]));
  except
    on E: Exception do
    begin
      GLogger.Error('请求失败: ' + E.Message);
      raise;
    end;
  end;
end;
```

---

## 常见问题

### Q1: 如何处理自签名证书？

```pascal
// 方法1：禁用验证（仅测试）
LOptions.VerifyPeer := False;

// 方法2：添加自定义CA（推荐）
LOptions.CAFile := 'path/to/ca.pem';
LOptions.VerifyPeer := True;
```

### Q2: 如何设置代理？

```pascal
// 目前版本不直接支持HTTP代理
// 可以使用系统代理或SOCKS代理
```

### Q3: 如何处理重定向？

```pascal
LOptions.FollowRedirects := True;
LOptions.MaxRedirects := 5;
```

### Q4: 如何处理大文件？

```pascal
// 使用Download方法，自动流式处理
TSimpleHTTPSClient.Download(LURL, LDestFile);
```

### Q5: 如何实现并发请求？

```pascal
uses
  Classes, SyncObjs;

type
  TRequestThread = class(TThread)
  private
    FURL: string;
    FResult: string;
  protected
    procedure Execute; override;
  public
    constructor Create(const AURL: string);
    property Result: string read FResult;
  end;

constructor TRequestThread.Create(const AURL: string);
begin
  inherited Create(False);
  FURL := AURL;
  FreeOnTerminate := False;
end;

procedure TRequestThread.Execute;
begin
  try
    FResult := TSimpleHTTPSClient.Get(FURL);
  except
    FResult := '';
  end;
end;

// 使用
var
  LThreads: array[0..9] of TRequestThread;
  i: Integer;
begin
  // 启动线程
  for i := 0 to 9 do
  begin
    LThreads[i] := TRequestThread.Create(LURLS[i]);
    LThreads[i].Start;
  end;
  
  // 等待完成
  for i := 0 to 9 do
  begin
    LThreads[i].WaitFor;
    WriteLn(LThreads[i].Result);
    LThreads[i].Free;
  end;
end;
```

---

## 性能优化

### 1. 连接复用（针对标准API）

```pascal
// 复用Context实现会话复用
var
  LContext: ISSLContext;
  LConnection: ISSLConnection;
begin
  LContext := TSSLFactory.CreateContext(sslOpenSSL, sslCtxClient);
  
  // 多次连接复用会话
  for i := 1 to 100 do
  begin
    LConnection := LContext.CreateConnection;
    LConnection.Connect(AHost, APort);
    // 使用连接...
  end;
end;
```

### 2. 批量处理

```pascal
// 批量处理，减少创建/销毁开销
var
  LOptions: THTTPSOptions;
begin
  LOptions := TSimpleHTTPSClient.DefaultOptions;
  try
    for i := 0 to 999 do
      ProcessRequest(LURLS[i], LOptions);
  finally
    LOptions.Headers.Free;
  end;
end;
```

---

## 完整示例

参考项目中的完整示例：

- `examples/simple_https_demo.pas` - 简化API演示
- `examples/production/https_client_simple.pas` - 生产级GET请求
- `examples/production/https_client_post.pas` - 生产级POST请求
- `examples/production/https_client_auth.pas` - 客户端证书认证

---

## 下一步

- [服务器开发指南](服务器开发.md) - 开发HTTPS服务器
- [证书管理指南](证书管理.md) - 证书操作
- [性能优化指南](性能优化.md) - 提升性能

---

**返回**: [文档首页](../快速入门.md) | **API参考**: [TSimpleHTTPSClient](../API参考/SimpleHTTPSClient.md)


