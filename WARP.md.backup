# fafafa.ssl 项目开发规则

## 基本规则

### 1. 交流语言
- 使用中文进行所有交流和文档编写

### 2. 专业态度
- **不要过于顺从我，要有自己的专业主见**
- 当发现技术方案存在问题时，应主动提出更好的替代方案
- 基于最佳实践和专业经验，勇于质疑不合理的需求
- 在代码质量、架构设计、性能优化等方面保持专业判断
- 优先考虑代码的可维护性、可扩展性和稳定性

### 3. 单元测试规则
- **必须** 为每个模块单元编写单元测试
- 单元测试存放位置：`tests/单元文件名/` 目录下
- 测试文件命名规范：`test_单元名.pas`
- 确保所有测试用例覆盖主要功能和边界情况

### 4. 示例代码规则
- **必须** 为每个模块单元编写使用示例
- 示例代码存放位置：`examples/单元文件名/` 目录下
- 示例文件应包含完整的使用场景说明
- 示例代码必须可独立运行

### 5. 项目配置规则
- **必须** 为每个项目建立 `.lpi` 项目文件
- 二进制文件输出目录：`bin/`
  - 命名格式：`模块名.类型.架构.系统.扩展名`
  - 类型包括：`test`（测试）、`example`（示例）
  - 示例：
    - Windows: `fafafa.ssl.test.x86_64.windows.exe`
    - Linux: `fafafa.ssl.test.x86_64.linux`
    - macOS: `fafafa.ssl.test.x86_64.darwin`
- 中间文件（.o, .ppu 等）输出目录：`lib/$(TargetCPU)-$(TargetOS)/`
- 项目文件配置示例：
  ```xml
  <Target>
    <Filename Value="bin/模块名.类型.$(TargetCPU).$(TargetOS)"/>
  </Target>
  <SearchPaths>
    <UnitOutputDirectory Value="lib/$(TargetCPU)-$(TargetOS)"/>
  </SearchPaths>
  ```

### 6. 代码风格规范

#### 6.1 编码设置
- **Windows平台UTF-8支持**：如果程序需要输出中文或Unicode符号，必须添加：
  ```pascal
  {$IFDEF WINDOWS}{$CODEPAGE UTF8}{$ENDIF}
  ```
  - 原因：Windows下不设置UTF-8代码页会导致输出Unicode字符时出现"Disk Full"等错误
  - 位置：放在程序或单元的编译指令部分（通常在 `{$MODE}` 指令后）
  - 示例：
    ```pascal
    program MyProgram;
    {$MODE ObjFPC}{$H+}
    {$IFDEF WINDOWS}{$CODEPAGE UTF8}{$ENDIF}
    ```

#### 6.2 变量命名规则
- **局部变量**：必须以 `L` 开头
  - 示例：`LCount`, `LIndex`, `LResult`, `LTempString`
  
- **参数命名**：必须以 `a` 开头
  - 示例：`aCount`, `aFileName`, `aOptions`, `aCallback`

#### 6.3 其他命名约定
- **类名**：以 `T` 开头，如 `THttpClient`
- **接口名**：以 `I` 开头，如 `IHttpRequest`
- **常量名**：全大写，单词间用下划线分隔，如 `MAX_CONNECTIONS`
- **私有字段**：以 `F` 开头，如 `FConnection`
- **属性名**：Pascal 命名法，如 `ConnectionTimeout`

### 7. 目录结构规范
```
项目根目录/
├── bin/                    # 二进制输出目录（所有平台二进制放在同一目录）
│   ├── 模块名.test.x86_64.windows.exe
│   ├── 模块名.example.x86_64.windows.exe
│   └── ...
├── lib/                    # 中间文件目录
│   └── x86_64-win64/      # 平台特定目录
├── src/                    # 源代码目录
│   ├── 单元名.pas
│   └── ...
├── tests/                  # 单元测试目录
│   ├── 单元文件名/
│   │   ├── test_单元名.pas
│   │   └── test_单元名.lpi
│   └── ...
├── examples/               # 示例代码目录
│   ├── 单元文件名/
│   │   ├── example_基本用法.pas
│   │   ├── example_高级功能.pas
│   │   └── example_项目.lpi
│   └── ...
├── docs/                   # 文档目录
├── README.md              # 项目说明文件
└── WARP.md               # 本规则文件
```

### 8. 代码质量要求
- 所有公共方法必须有注释说明
- 复杂逻辑必须添加解释性注释
- 使用有意义的变量和函数名
- 避免过长的函数（建议不超过 50 行）
- 每个单元文件应只包含一个主要功能

### 9. 代码改动规范
- **重大架构改变必须先申请审批**
  - 包括但不限于：改变核心数据结构、引入新的依赖、改变API接口
  - 必须先说明改动理由、影响范围、性能对比
  - 未经批准不得擅自进行重大重构
- **优先选择简单方案**
  - 避免过度设计和过早优化
  - 优先使用标准库和简单数据结构
  - 只有在明确的性能瓶颈时才引入复杂优化

### 10. 版本控制规范
- 提交信息使用中文
- 提交格式：`[类型] 简短描述`
  - 类型包括：新增、修复、优化、重构、文档、测试
  - 示例：`[新增] 添加 OpenSSL 后端实现`
- 每次提交应只包含一个功能变更

### 11. 特定于 SSL/TLS 库的规则
- 必须支持多种 SSL/TLS 后端（OpenSSL、WolfSSL、MbedTLS）
- 提供统一的抽象接口，屏蔽底层实现差异
- 必须实现完善的错误处理机制，包含原生错误码映射
- 支持多种 TLS 协议版本（TLS 1.0-1.3）
- 支持证书验证和自定义证书链
- 实现连接超时和握手超时控制
- 提供详细的连接信息获取（协议版本、密码套件等）
- 确保内存管理安全，避免泄漏
- 支持客户端和服务端模式
- 考虑性能优化，最小化上下文切换开销

### 12. 模块化设计最佳实践

#### 12.1 大文件拆分策略
- **将大型单一文件拆分为多个功能专注的子模块**
  - 每个模块应聚焦于单一职责
  - 模块之间通过清晰的接口进行交互
  - 避免单个文件超过 1000 行代码

#### 12.2 模块组织原则
- **按功能域进行划分**
  - 示例：OpenSSL 绑定拆分为：
    - `fafafa.ssl.openssl.types` - 类型定义
    - `fafafa.ssl.openssl.consts` - 常量定义
    - `fafafa.ssl.openssl.core` - 核心功能
    - `fafafa.ssl.openssl.evp` - EVP 加密接口
    - `fafafa.ssl.openssl.ssl` - SSL/TLS 功能
    - `fafafa.ssl.openssl.x509` - 证书管理
    - `fafafa.ssl.openssl.bio` - I/O 抽象层

#### 12.3 模块化的优势
- **提高代码可维护性**
  - 易于定位和修改特定功能
  - 降低代码耦合度
  - 便于团队协作开发
  
- **增强代码可读性**
  - 每个模块功能明确
  - 减少认知负担
  - 便于新开发者理解项目结构
  
- **改善编译性能**
  - 修改单个模块时只需重编译相关部分
  - 减少全量编译时间
  - 支持并行编译

#### 12.4 模块依赖管理
- **建立清晰的依赖层次**
  - 基础类型和常量模块不依赖其他模块
  - 核心模块只依赖基础模块
  - 高级功能模块可依赖核心和基础模块
  - 避免循环依赖

#### 12.5 接口设计原则
- **最小化公开接口**
  - 只暴露必要的类型和函数
  - 使用 `interface` 部分定义公共 API
  - 内部实现细节保留在 `implementation` 部分
  
- **保持接口稳定性**
  - 一旦发布，避免破坏性变更
  - 使用版本化策略管理 API 演进
  - 提供向后兼容的迁移路径

### 13. 渐进式开发最佳实践

#### 13.1 分批完成策略
- **将大型任务分解为多个小批次**
  - 每批完成 3-5 个相关模块
  - 每批次后进行总结和反馈
  - 避免一次性实现所有功能导致上下文溢出

#### 13.2 进度追踪方法
- **完成部分总结**
  - 明确列出已完成的模块及其功能
  - 标注每个模块的完成度（骨架/基本/完整）
  - 记录关键功能亮点
  
- **待办事项管理**
  - 清晰列出剩余待实现的模块
  - 按优先级和依赖关系排序
  - 提供继续的明确方向

#### 13.3 上下文保持技巧
- **使用"继续"关键词**
  - 用户简单说"继续"即可延续之前的开发
  - AI 会根据之前的总结继续实现下一批模块
  - 避免重复说明需求，节省交流成本
  
- **阶段性总结模板**
  ```markdown
  ## 已完成的模块
  1. 模块A - 功能描述
  2. 模块B - 功能描述
  ...
  
  ## 功能亮点
  - 亮点1
  - 亮点2
  ...
  
  ## 待实现的模块
  - 模块X
  - 模块Y
  ...
  
  您想让我继续创建哪些模块呢？
  ```

#### 13.4 实践优势
- **防止上下文丢失**
  - 通过总结锁定已完成的工作
  - 明确的待办事项指引方向
  - 便于中断后恢复开发
  
- **提高开发效率**
  - 聚焦当前批次的模块
  - 减少认知负担
  - 便于验证和测试
  
- **增强协作体验**
  - 用户清楚了解进度
  - AI 保持开发连贯性
  - 双方都有明确预期

## 检查清单

在提交代码前，请确保：
- [ ] 代码遵循命名规范（局部变量 L 开头，参数 a 开头）
- [ ] 已编写对应的单元测试
- [ ] 已编写使用示例
- [ ] 项目文件配置正确（bin 和 lib 目录）
- [ ] 代码有适当的注释
- [ ] 所有测试通过
- [ ] 文档已更新

## 备注
本文档会根据项目发展持续更新，请定期查看最新版本。

---
最后更新时间：2025-09-28（适配 fafafa.ssl 项目）

---

## 14. Warp AI 协作范式

### 14.1 协作原则

#### 明确目标导向

**✅ 好的做法**:
- "测试OpenSSL后端的加密模块，优先级从高到低"
- "找出SHA3测试失败的根本原因"
- "创建完整的测试文档体系"

**❌ 避免**:
- "测试一些东西"
- "看看有什么问题"
- "随便做点什么"

#### 分阶段推进

**工作流程**:
1. **规划** → 确定优先级和范围
2. **执行** → 系统性完成任务
3. **分析** → 深入理解问题
4. **文档** → 记录发现和解决方案
5. **总结** → 提炼关键洞察

#### 最佳实践驱动

当不确定下一步时，说"按最佳实践继续"，AI会：
- 评估当前状态
- 选择最合理的下一步
- 平衡速度与质量
- 考虑长期价值

### 14.2 有效的协作模式

#### 测试驱动开发

**模式**: 测试 → 分析 → 文档 → 规划

**示例**:
1. "运行测试并分析结果"
2. "深入调查失败的测试"
3. "记录问题的根本原因"
4. "制定解决方案路线图"

#### 问题驱动调查

**模式**: 发现 → 重现 → 诊断 → 解决 → 预防

**示例**: SHA3失败调查
1. 发现: SHA3测试7/8失败
2. 重现: 创建诊断程序
3. 诊断: 发现函数指针为NULL
4. 解决: 制定EVP接口迁移方案
5. 预防: 文档化OpenSSL 3.x兼容性策略

#### 文档驱动协作

**模式**: 工作 → 记录 → 分享 → 改进

**关键文档类型**:
- **README**: 导航和快速入门
- **SUMMARY**: 高层次概览
- **ANALYSIS**: 深度技术分析
- **STRATEGY**: 长期规划
- **WORKING**: 工作日志
- **WARP**: 协作范式（本文档）

### 14.3 实用技巧

#### 利用AI的优势

**AI擅长的任务**:
- ✅ 编写重复性代码（测试用例）
- ✅ 生成结构化文档
- ✅ 分析大量数据（测试结果）
- ✅ 查找模式和异常
- ✅ 制定系统化方案

**人类更擅长的**:
- ✅ 战略决策
- ✅ 优先级判断
- ✅ 创造性思维
- ✅ 最终质量把关

#### 清晰的指令

**结构化请求**:
```
任务: 创建SHA3测试程序
要求:
- 基于现有test_seed.lpr结构
- 测试SHA3-256和SHA3-512
- 包含Init/Update/Final测试
- 详细的错误日志
```

#### 迭代改进

**循环**: 尝试 → 反馈 → 调整 → 完善

### 14.4 本项目中的成功实践

#### 系统化测试方法

**做法**:
- 按优先级测试（核心→重要→次要）
- 每个模块独立测试程序
- 统一的测试结果格式
- 自动化测试运行器

**成果**:
- 20个模块，176个测试
- 95.5%通过率
- 清晰的问题识别

#### 深度问题分析

**做法**:
- 不满足于表面现象
- 创建专门的诊断工具
- 研究底层API文档
- 验证假设

**成果**:
- 找到SHA3的真正原因（API不导出）
- 理解OpenSSL 3.x架构变化
- 制定清晰的迁移路径

#### 完整文档体系

**做法**:
- 多层次文档（快速入门→深度分析）
- 结构化内容（目录、章节、标记）
- 实用信息（代码示例、时间估算）
- 可操作计划（优先级、任务列表）

**成果**:
- 7个主要文档
- 30,000+字
- 完整的知识传承

#### 战略性思维

**做法**:
- 识别根本性问题（OpenSSL 3.x兼容性）
- 评估多种策略（运行时vs编译时vs EVP-only）
- 分阶段实施（关键→重要→次要）
- 长期规划（40-60小时工作量）

**成果**:
- 清晰的技术路线图
- 可执行的实施计划
- 风险评估和缓解

### 14.5 加速协作的技巧

#### 使用"继续"

当工作连续性好时，简单说"继续"，AI会：
- 保持当前上下文
- 按既定方向推进
- 自动进入下一个逻辑步骤

#### 使用"按最佳实践"

当不确定方向时，说"按最佳实践"，AI会：
- 评估当前状态
- 选择最优方案
- 解释选择理由

#### 明确反馈

**有效反馈**:
- "好，继续下一个模块"
- "这个分析很好，创建文档"
- "问题找到了，现在制定解决方案"

#### 分阶段确认

**检查点**:
- 完成测试后确认结果
- 分析完问题后确认方向
- 完成文档后总体回顾

### 14.6 常见陷阱

#### 过度依赖

**陷阱**: 不加思考地接受所有建议

**解决**: 
- 理解AI的推理
- 验证关键决策
- 保持批判性思维

#### 目标不清

**陷阱**: "帮我看看这个项目"

**解决**:
- 明确具体目标
- 设定成功标准
- 分阶段推进

#### 忽视文档

**陷阱**: 只关注代码，不记录过程

**解决**:
- 同时进行工作和文档
- 记录决策原因
- 维护工作日志

#### 缺乏验证

**陷阱**: 生成代码后不测试

**解决**:
- 编译验证
- 运行测试
- 检查输出

### 14.7 成功指标

#### 好的协作会话特征

✅ **目标明确**: 知道要做什么  
✅ **进展可见**: 清晰的里程碑  
✅ **质量保证**: 测试和验证  
✅ **文档完整**: 知识可传承  
✅ **价值产出**: 解决实际问题

#### 量化指标（2025-09-30工作）

- **效率**: 8小时完成20模块测试+7文档
- **质量**: 95.5%测试通过率
- **深度**: 找到3个问题的根本原因
- **价值**: 40-60小时的实施计划

### 14.8 推荐实践

#### 开始新工作时

1. **回顾上次**: 阅读WORKING.md了解状态
2. **明确目标**: "我要完成[具体任务]"
3. **确认方法**: "按照[方法]进行"
4. **设定标准**: "成功是指[标准]"

#### 工作进行中

1. **定期确认**: "这样对吗？"
2. **调整方向**: "改成[新方向]"
3. **保存进度**: "提交当前成果"
4. **记录发现**: "更新文档"

#### 工作结束时

1. **总结成果**: "总结今天的工作"
2. **更新日志**: "更新WORKING.md"
3. **提交代码**: "git commit记录"
4. **计划下次**: "下次应该做[任务]"

### 14.9 核心原则总结

1. **目标驱动**: 始终知道要达到什么目标
2. **系统方法**: 用结构化方式解决问题
3. **深度分析**: 找到根本原因，不是表象
4. **完整文档**: 记录过程和决策
5. **持续改进**: 反思和优化工作方式
6. **价值导向**: 聚焦真正重要的事情
7. **质量保证**: 测试验证所有产出

**记住**: Warp AI是工具，你是掌舵者。
- AI提供速度和广度
- 人类提供方向和深度
- 最佳协作 = AI能力 × 人类智慧

---

## 更新历史
- 2025-09-30：添加Warp AI协作范式（第14节）- 记录测试和问题分析的协作最佳实践
- 2025-09-29：添加渐进式开发最佳实践（第13节）- 记录分批完成和上下文保持的优秀实践
- 2025-09-29：添加模块化设计最佳实践（第12节）- 记录大文件拆分为子模块的优秀实践
- 2025-09-28：适配 fafafa.ssl 项目 - 更新特定规则为 SSL/TLS 库相关
- 2025-09-28：添加专业态度规则（第2节）- 强调不要过于顺从，要有专业主见
- 2025-09-27：更新二进制文件命名规则（第5节）- 采用扁平化命名方式
- 2025-09-27：添加 Windows UTF-8 代码页设置规范（6.1节）
