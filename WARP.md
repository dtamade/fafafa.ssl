# fafafa.ssl 项目开发规则

## 基本规则

### 1. 交流语言
- 使用中文进行所有交流和文档编写

### 2. 专业态度
- **不要过于顺从我，要有自己的专业主见**
- 当发现技术方案存在问题时，应主动提出更好的替代方案
- 基于最佳实践和专业经验，勇于质疑不合理的需求
- 在代码质量、架构设计、性能优化等方面保持专业判断
- 优先考虑代码的可维护性、可扩展性和稳定性

### 3. 单元测试规则
- **必须** 为每个模块单元编写单元测试
- 单元测试存放位置：`tests/单元文件名/` 目录下
- 测试文件命名规范：`test_单元名.pas`
- 确保所有测试用例覆盖主要功能和边界情况

### 4. 示例代码规则
- **必须** 为每个模块单元编写使用示例
- 示例代码存放位置：`examples/单元文件名/` 目录下
- 示例文件应包含完整的使用场景说明
- 示例代码必须可独立运行

### 5. 项目配置规则
- **必须** 为每个项目建立 `.lpi` 项目文件
- 二进制文件输出目录：`bin/`
  - 命名格式：`模块名.类型.架构.系统.扩展名`
  - 类型包括：`test`（测试）、`example`（示例）
  - 示例：
    - Windows: `fafafa.ssl.test.x86_64.windows.exe`
    - Linux: `fafafa.ssl.test.x86_64.linux`
    - macOS: `fafafa.ssl.test.x86_64.darwin`
- 中间文件（.o, .ppu 等）输出目录：`lib/$(TargetCPU)-$(TargetOS)/`
- 项目文件配置示例：
  ```xml
  <Target>
    <Filename Value="bin/模块名.类型.$(TargetCPU).$(TargetOS)"/>
  </Target>
  <SearchPaths>
    <UnitOutputDirectory Value="lib/$(TargetCPU)-$(TargetOS)"/>
  </SearchPaths>
  ```

### 6. 代码风格规范

#### 6.1 编码设置
- **Windows平台UTF-8支持**：如果程序需要输出中文或Unicode符号，必须添加：
  ```pascal
  {$IFDEF WINDOWS}{$CODEPAGE UTF8}{$ENDIF}
  ```
  - 原因：Windows下不设置UTF-8代码页会导致输出Unicode字符时出现"Disk Full"等错误
  - 位置：放在程序或单元的编译指令部分（通常在 `{$MODE}` 指令后）
  - 示例：
    ```pascal
    program MyProgram;
    {$MODE ObjFPC}{$H+}
    {$IFDEF WINDOWS}{$CODEPAGE UTF8}{$ENDIF}
    ```

#### 6.2 变量命名规则
- **局部变量**：必须以 `L` 开头
  - 示例：`LCount`, `LIndex`, `LResult`, `LTempString`
  
- **参数命名**：必须以 `a` 开头
  - 示例：`aCount`, `aFileName`, `aOptions`, `aCallback`

#### 6.3 其他命名约定
- **类名**：以 `T` 开头，如 `THttpClient`
- **接口名**：以 `I` 开头，如 `IHttpRequest`
- **常量名**：全大写，单词间用下划线分隔，如 `MAX_CONNECTIONS`
- **私有字段**：以 `F` 开头，如 `FConnection`
- **属性名**：Pascal 命名法，如 `ConnectionTimeout`

### 7. 目录结构规范
```
项目根目录/
├── bin/                    # 二进制输出目录（所有平台二进制放在同一目录）
│   ├── 模块名.test.x86_64.windows.exe
│   ├── 模块名.example.x86_64.windows.exe
│   └── ...
├── lib/                    # 中间文件目录
│   └── x86_64-win64/      # 平台特定目录
├── src/                    # 源代码目录
│   ├── 单元名.pas
│   └── ...
├── tests/                  # 单元测试目录
│   ├── 单元文件名/
│   │   ├── test_单元名.pas
│   │   └── test_单元名.lpi
│   └── ...
├── examples/               # 示例代码目录
│   ├── 单元文件名/
│   │   ├── example_基本用法.pas
│   │   ├── example_高级功能.pas
│   │   └── example_项目.lpi
│   └── ...
├── docs/                   # 文档目录
├── README.md              # 项目说明文件
└── WARP.md               # 本规则文件
```

### 8. 代码质量要求
- 所有公共方法必须有注释说明
- 复杂逻辑必须添加解释性注释
- 使用有意义的变量和函数名
- 避免过长的函数（建议不超过 50 行）
- 每个单元文件应只包含一个主要功能

### 9. 代码改动规范
- **重大架构改变必须先申请审批**
  - 包括但不限于：改变核心数据结构、引入新的依赖、改变API接口
  - 必须先说明改动理由、影响范围、性能对比
  - 未经批准不得擅自进行重大重构
- **优先选择简单方案**
  - 避免过度设计和过早优化
  - 优先使用标准库和简单数据结构
  - 只有在明确的性能瓶颈时才引入复杂优化

### 10. 版本控制规范
- 提交信息使用中文
- 提交格式：`[类型] 简短描述`
  - 类型包括：新增、修复、优化、重构、文档、测试
  - 示例：`[新增] 添加 OpenSSL 后端实现`
- 每次提交应只包含一个功能变更

### 11. 特定于 SSL/TLS 库的规则
- 必须支持多种 SSL/TLS 后端（OpenSSL、WolfSSL、MbedTLS）
- 提供统一的抽象接口，屏蔽底层实现差异
- 必须实现完善的错误处理机制，包含原生错误码映射
- 支持多种 TLS 协议版本（TLS 1.0-1.3）
- 支持证书验证和自定义证书链
- 实现连接超时和握手超时控制
- 提供详细的连接信息获取（协议版本、密码套件等）
- 确保内存管理安全，避免泄漏
- 支持客户端和服务端模式
- 考虑性能优化，最小化上下文切换开销

### 12. 模块化设计最佳实践

#### 12.1 大文件拆分策略
- **将大型单一文件拆分为多个功能专注的子模块**
  - 每个模块应聚焦于单一职责
  - 模块之间通过清晰的接口进行交互
  - 避免单个文件超过 1000 行代码

#### 12.2 模块组织原则
- **按功能域进行划分**
  - 示例：OpenSSL 绑定拆分为：
    - `fafafa.ssl.openssl.types` - 类型定义
    - `fafafa.ssl.openssl.consts` - 常量定义
    - `fafafa.ssl.openssl.core` - 核心功能
    - `fafafa.ssl.openssl.evp` - EVP 加密接口
    - `fafafa.ssl.openssl.ssl` - SSL/TLS 功能
    - `fafafa.ssl.openssl.x509` - 证书管理
    - `fafafa.ssl.openssl.bio` - I/O 抽象层

#### 12.3 模块化的优势
- **提高代码可维护性**
  - 易于定位和修改特定功能
  - 降低代码耦合度
  - 便于团队协作开发
  
- **增强代码可读性**
  - 每个模块功能明确
  - 减少认知负担
  - 便于新开发者理解项目结构
  
- **改善编译性能**
  - 修改单个模块时只需重编译相关部分
  - 减少全量编译时间
  - 支持并行编译

#### 12.4 模块依赖管理
- **建立清晰的依赖层次**
  - 基础类型和常量模块不依赖其他模块
  - 核心模块只依赖基础模块
  - 高级功能模块可依赖核心和基础模块
  - 避免循环依赖

#### 12.5 接口设计原则
- **最小化公开接口**
  - 只暴露必要的类型和函数
  - 使用 `interface` 部分定义公共 API
  - 内部实现细节保留在 `implementation` 部分
  
- **保持接口稳定性**
  - 一旦发布，避免破坏性变更
  - 使用版本化策略管理 API 演进
  - 提供向后兼容的迁移路径

### 13. 渐进式开发最佳实践

#### 13.1 分批完成策略
- **将大型任务分解为多个小批次**
  - 每批完成 3-5 个相关模块
  - 每批次后进行总结和反馈
  - 避免一次性实现所有功能导致上下文溢出

#### 13.2 进度追踪方法
- **完成部分总结**
  - 明确列出已完成的模块及其功能
  - 标注每个模块的完成度（骨架/基本/完整）
  - 记录关键功能亮点
  
- **待办事项管理**
  - 清晰列出剩余待实现的模块
  - 按优先级和依赖关系排序
  - 提供继续的明确方向

#### 13.3 上下文保持技巧
- **使用"继续"关键词**
  - 用户简单说"继续"即可延续之前的开发
  - AI 会根据之前的总结继续实现下一批模块
  - 避免重复说明需求，节省交流成本
  
- **阶段性总结模板**
  ```markdown
  ## 已完成的模块
  1. 模块A - 功能描述
  2. 模块B - 功能描述
  ...
  
  ## 功能亮点
  - 亮点1
  - 亮点2
  ...
  
  ## 待实现的模块
  - 模块X
  - 模块Y
  ...
  
  您想让我继续创建哪些模块呢？
  ```

#### 13.4 实践优势
- **防止上下文丢失**
  - 通过总结锁定已完成的工作
  - 明确的待办事项指引方向
  - 便于中断后恢复开发
  
- **提高开发效率**
  - 聚焦当前批次的模块
  - 减少认知负担
  - 便于验证和测试
  
- **增强协作体验**
  - 用户清楚了解进度
  - AI 保持开发连贯性
  - 双方都有明确预期

## 检查清单

在提交代码前，请确保：
- [ ] 代码遵循命名规范（局部变量 L 开头，参数 a 开头）
- [ ] 已编写对应的单元测试
- [ ] 已编写使用示例
- [ ] 项目文件配置正确（bin 和 lib 目录）
- [ ] 代码有适当的注释
- [ ] 所有测试通过
- [ ] 文档已更新

## 备注
本文档会根据项目发展持续更新，请定期查看最新版本。

---
最后更新时间：2025-09-28（适配 fafafa.ssl 项目）

## 更新历史
- 2025-09-29：添加渐进式开发最佳实践（第13节）- 记录分批完成和上下文保持的优秀实践
- 2025-09-29：添加模块化设计最佳实践（第12节）- 记录大文件拆分为子模块的优秀实践
- 2025-09-28：适配 fafafa.ssl 项目 - 更新特定规则为 SSL/TLS 库相关
- 2025-09-28：添加专业态度规则（第2节）- 强调不要过于顺从，要有专业主见
- 2025-09-27：更新二进制文件命名规则（第5节）- 采用扁平化命名方式
- 2025-09-27：添加 Windows UTF-8 代码页设置规范（6.1节）
